create table udt_infos (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text not null,
    code_hash text not null,
    hash_type varchar(10) not null,
    args text not null,
    auto_accept_amount text -- u64 with hexadecimal format
);

create table udt_dep (
    outpoint_tx_hash text,
    outpoint_index text,
    dep_type varchar(10),
    code_hash text,
    hash_type varchar(10),
    args text,
    udt_info_id integer not null references udt_infos(id)
);

create table node_udt_relations (
    node_id text not null,
    udt_info_id integer not null references udt_infos(id)
);

create table daily_summarized_data (
    day date NOT NULL PRIMARY KEY,
    channels_count INTEGER NOT NULL,
    nodes_count INTEGER NOT NULL,
    sum_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    avg_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    min_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    max_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    median_capacity TEXT NOT NULL -- u128 with hexadecimal format
);

create table channel_states (
    channel_outpoint TEXT NOT NULL PRIMARY KEY,
    funding_args TEXT NOT NULL,
    last_tx_hash TEXT NOT NULL,
    last_block_number TEXT NOT NULL,
    last_commitment_args TEXT,
    state TEXT NOT NULL
);

create table channel_txs (
    channel_outpoint TEXT NOT NULL REFERENCES channel_states(channel_outpoint),
    tx_hash TEXT NOT NULL,
    block_number TEXT NOT NULL,
    witness_args TEXT,
    commitment_args TEXT
);

create index idx_udt_dep_id on udt_dep(udt_info_id);
create index idx_node_udt_relations_udt on node_udt_relations(udt_info_id);
create index idx_node_udt_relations_node on node_udt_relations(node_id);
create index idx_daily_summarized_data_day on daily_summarized_data(day);
create index idx_channel_txs_outpoint on channel_txs(channel_outpoint);
create index idx_channel_states_state on channel_states(state);

create table node_infos (
    time TIMESTAMPTZ NOT NULL,
    node_name TEXT NOT NULL,
    node_id TEXT NOT NULL,
    addresses TEXT NOT NULL,
    announce_timestamp TIMESTAMPTZ NOT NULL,
    chain_hash TEXT NOT NULL,
    auto_accept_min_ckb_funding_amount TEXT NOT NULL,
    country TEXT,
    city TEXT,
    region TEXT,
    loc TEXT
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='node_id',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_node_id_time
  ON node_infos(node_id, time DESC);

create table channel_infos (
    time TIMESTAMPTZ NOT NULL,
    channel_outpoint TEXT NOT NULL,
    node1 TEXT NOT NULL,
    node2 TEXT NOT NULL,
    capacity TEXT NOT NULL, -- u128 with hexadecimal format
    chain_hash TEXT NOT NULL,
    udt_type_script integer, -- foreign key to udt_infos
    created_timestamp TIMESTAMPTZ NOT NULL,
    update_of_node1_timestamp TIMESTAMPTZ,
    update_of_node1_enabled BOOLEAN,
    update_of_node1_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node1_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node1_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node1_fee_rate TEXT, -- u64 with hexadecimal format
    update_of_node2_timestamp TIMESTAMPTZ,
    update_of_node2_enabled BOOLEAN,
    update_of_node2_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node2_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node2_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node2_fee_rate TEXT -- u64 with hexadecimal format
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='channel_outpoint',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_channel_outpoint_time
  ON channel_infos(channel_outpoint, time DESC);


CREATE MATERIALIZED VIEW online_nodes_hourly
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  node_id,
  -- get the latest information for each node
  last(node_name, time) AS node_name,
  last(addresses, time) AS addresses,
  last(announce_timestamp, time) AS announce_timestamp,
  last(chain_hash, time) AS chain_hash,
  last(auto_accept_min_ckb_funding_amount, time) AS auto_accept_min_ckb_funding_amount,
  last(country, time) AS country,
  last(city, time) AS city,
  last(region, time) AS region,
  last(loc, time) AS loc
FROM node_infos
-- group by node ID to ensure each node appears only once
GROUP BY bucket, node_id
WITH NO DATA;

-- bucket by hour, so the data will be aggregated every hour
-- it means that 2025-08-07 03:00:00+00 will be aggregated after 2025-08-07 04:10:00+00
SELECT add_continuous_aggregate_policy(
  'online_nodes_hourly',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_nodes_hourly', INTERVAL '12 months');

create index idx_node_hourly_id_time
  ON online_nodes_hourly(node_id, bucket DESC);

CREATE MATERIALIZED VIEW online_channels_hourly
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  channel_outpoint,
  -- get the latest information for each channel
  last(node1, time) AS node1,
  last(node2, time) AS node2,
  last(capacity, time) AS capacity,
  last(chain_hash, time) AS chain_hash,
  last(udt_type_script, time) AS udt_type_script,
  last(created_timestamp, time) AS created_timestamp,
  last(update_of_node1_timestamp, time) AS update_of_node1_timestamp,
  last(update_of_node1_enabled, time) AS update_of_node1_enabled,
  last(update_of_node1_outbound_liquidity, time) AS update_of_node1_outbound_liquidity,
  last(update_of_node1_tlc_expiry_delta, time) AS update_of_node1_tlc_expiry_delta,
  last(update_of_node1_tlc_minimum_value, time) AS update_of_node1_tlc_minimum_value,
  last(update_of_node1_fee_rate, time) AS update_of_node1_fee_rate,
  last(update_of_node2_timestamp, time) AS update_of_node2_timestamp,
  last(update_of_node2_enabled, time) AS update_of_node2_enabled,
  last(update_of_node2_outbound_liquidity, time) AS update_of_node2_outbound_liquidity,
  last(update_of_node2_tlc_expiry_delta, time) AS update_of_node2_tlc_expiry_delta,
  last(update_of_node2_tlc_minimum_value, time) AS update_of_node2_tlc_minimum_value,
  last(update_of_node2_fee_rate, time) AS update_of_node2_fee_rate
FROM channel_infos
-- group by channel outpoint to ensure each channel appears only once
GROUP BY bucket, channel_outpoint
WITH NO DATA;

SELECT add_continuous_aggregate_policy(
  'online_channels_hourly',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_channels_hourly', INTERVAL '12 months');

create index idx_channels_hourly_node1
  ON online_channels_hourly(node1, bucket DESC);

create index idx_channels_hourly_node2
  ON online_channels_hourly(node2, bucket DESC);

create index idx_channels_hourly_outpoint_time
  ON online_channels_hourly(channel_outpoint, bucket DESC);


--- testnet

create table udt_infos_testnet (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text not null,
    code_hash text not null,
    hash_type varchar(10) not null,
    args text not null,
    auto_accept_amount text -- u64 with hexadecimal format
);

create table udt_dep_testnet (
    outpoint_tx_hash text,
    outpoint_index text,
    dep_type varchar(10),
    code_hash text,
    hash_type varchar(10),
    args text,
    udt_info_id integer not null references udt_infos_testnet(id)
);

create table node_udt_relations_testnet (
    node_id text not null,
    udt_info_id integer not null references udt_infos_testnet(id)
);

create table daily_summarized_data_testnet (
    day date NOT NULL PRIMARY KEY,
    channels_count INTEGER NOT NULL,
    nodes_count INTEGER NOT NULL,
    sum_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    avg_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    min_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    max_capacity TEXT NOT NULL, -- u128 with hexadecimal format
    median_capacity TEXT NOT NULL -- u128 with hexadecimal format
);

create table channel_states_testnet (
    channel_outpoint TEXT NOT NULL PRIMARY KEY,
    funding_args TEXT NOT NULL,
    last_tx_hash TEXT NOT NULL,
    last_block_number TEXT NOT NULL,
    last_commitment_args TEXT,
    state TEXT NOT NULL
);

create table channel_txs_testnet (
    channel_outpoint TEXT NOT NULL REFERENCES channel_states_testnet(channel_outpoint),
    tx_hash TEXT NOT NULL,
    block_number TEXT NOT NULL,
    witness_args TEXT,
    commitment_args TEXT
);

create index idx_udt_dep_id_testnet on udt_dep_testnet(udt_info_id);
create index idx_node_udt_relations_udt_testnet on node_udt_relations_testnet(udt_info_id);
create index idx_node_udt_relations_node_testnet on node_udt_relations_testnet(node_id);
create index idx_daily_summarized_data_day_testnet on daily_summarized_data_testnet(day);
create index idx_channel_txs_outpoint_testnet on channel_txs_testnet(channel_outpoint);
create index idx_channel_states_state_testnet on channel_states_testnet(state);

create table node_infos_testnet (
    time TIMESTAMPTZ NOT NULL,
    node_name TEXT NOT NULL,
    node_id TEXT NOT NULL,
    addresses TEXT NOT NULL,
    announce_timestamp TIMESTAMPTZ NOT NULL,
    chain_hash TEXT NOT NULL,
    auto_accept_min_ckb_funding_amount TEXT NOT NULL,
    country TEXT,
    city TEXT,
    region TEXT,
    loc TEXT
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='node_id',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_node_id_time_testnet
  ON node_infos_testnet(node_id, time DESC);

create table channel_infos_testnet (
    time TIMESTAMPTZ NOT NULL,
    channel_outpoint TEXT NOT NULL,
    node1 TEXT NOT NULL,
    node2 TEXT NOT NULL,
    capacity TEXT NOT NULL, -- u128 with hexadecimal format
    chain_hash TEXT NOT NULL,
    udt_type_script integer, -- foreign key to udt_infos
    created_timestamp TIMESTAMPTZ NOT NULL,
    update_of_node1_timestamp TIMESTAMPTZ,
    update_of_node1_enabled BOOLEAN,
    update_of_node1_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node1_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node1_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node1_fee_rate TEXT, -- u64 with hexadecimal format
    update_of_node2_timestamp TIMESTAMPTZ,
    update_of_node2_enabled BOOLEAN,
    update_of_node2_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node2_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node2_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node2_fee_rate TEXT -- u64 with hexadecimal format
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='channel_outpoint',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_channel_outpoint_time_testnet
  ON channel_infos_testnet(channel_outpoint, time DESC);


CREATE MATERIALIZED VIEW online_nodes_hourly_testnet
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  node_id,
  -- get the latest information for each node
  last(node_name, time) AS node_name,
  last(addresses, time) AS addresses,
  last(announce_timestamp, time) AS announce_timestamp,
  last(chain_hash, time) AS chain_hash,
  last(auto_accept_min_ckb_funding_amount, time) AS auto_accept_min_ckb_funding_amount,
  last(country, time) AS country,
  last(city, time) AS city,
  last(region, time) AS region,
  last(loc, time) AS loc
FROM node_infos_testnet
-- group by node ID to ensure each node appears only once
GROUP BY bucket, node_id
WITH NO DATA;

-- bucket by hour, so the data will be aggregated every hour
-- it means that 2025-08-07 03:00:00+00 will be aggregated after 2025-08-07 04:10:00+00
SELECT add_continuous_aggregate_policy(
  'online_nodes_hourly_testnet',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_nodes_hourly_testnet', INTERVAL '12 months');

create index idx_node_hourly_id_time_testnet
  ON online_nodes_hourly_testnet(node_id, bucket DESC);

CREATE MATERIALIZED VIEW online_channels_hourly_testnet
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  channel_outpoint,
  -- get the latest information for each channel
  last(node1, time) AS node1,
  last(node2, time) AS node2,
  last(capacity, time) AS capacity,
  last(chain_hash, time) AS chain_hash,
  last(udt_type_script, time) AS udt_type_script,
  last(created_timestamp, time) AS created_timestamp,
  last(update_of_node1_timestamp, time) AS update_of_node1_timestamp,
  last(update_of_node1_enabled, time) AS update_of_node1_enabled,
  last(update_of_node1_outbound_liquidity, time) AS update_of_node1_outbound_liquidity,
  last(update_of_node1_tlc_expiry_delta, time) AS update_of_node1_tlc_expiry_delta,
  last(update_of_node1_tlc_minimum_value, time) AS update_of_node1_tlc_minimum_value,
  last(update_of_node1_fee_rate, time) AS update_of_node1_fee_rate,
  last(update_of_node2_timestamp, time) AS update_of_node2_timestamp,
  last(update_of_node2_enabled, time) AS update_of_node2_enabled,
  last(update_of_node2_outbound_liquidity, time) AS update_of_node2_outbound_liquidity,
  last(update_of_node2_tlc_expiry_delta, time) AS update_of_node2_tlc_expiry_delta,
  last(update_of_node2_tlc_minimum_value, time) AS update_of_node2_tlc_minimum_value,
  last(update_of_node2_fee_rate, time) AS update_of_node2_fee_rate
FROM channel_infos_testnet
-- group by channel outpoint to ensure each channel appears only once
GROUP BY bucket, channel_outpoint
WITH NO DATA;

SELECT add_continuous_aggregate_policy(
  'online_channels_hourly_testnet',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_channels_hourly_testnet', INTERVAL '12 months');

create index idx_channels_hourly_node1_testnet
  ON online_channels_hourly_testnet(node1, bucket DESC);

create index idx_channels_hourly_node2_testnet
  ON online_channels_hourly_testnet(node2, bucket DESC);

create index idx_channels_hourly_outpoint_time_testnet
  ON online_channels_hourly_testnet(channel_outpoint, bucket DESC);
