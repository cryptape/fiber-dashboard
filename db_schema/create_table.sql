create table udt_infos (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text not null,
    code_hash text not null,
    hash_type varchar(10) not null,
    args text not null,
    auto_accept_amount text -- u64 with hexadecimal format
);

create table udt_dep (
    outpoint_tx_hash text,
    outpoint_index text,
    dep_type varchar(10),
    code_hash text,
    hash_type varchar(10),
    args text,
    udt_info_id integer not null references udt_infos(id)
);

create table node_udt_relations (
    node_id text not null,
    udt_info_id integer not null references udt_infos(id)
);

create table daily_summarized_data (
    day date NOT NULL PRIMARY KEY,
    channels_count JSONB NOT NULL,
    nodes_count INTEGER NOT NULL,
    capacity_analysis JSONB NOT NULL,
    asset_analysis JSONB NOT NULL
);

create table channel_states (
    channel_outpoint TEXT NOT NULL PRIMARY KEY,
    funding_args TEXT NOT NULL,
    capacity TEXT NOT NULL,
    udt_value TEXT,
    create_time TIMESTAMPTZ NOT NULL,
    last_commit_time TIMESTAMPTZ NOT NULL,
    last_tx_hash TEXT NOT NULL,
    last_block_number TEXT NOT NULL,
    last_commitment_args TEXT,
    state TEXT NOT NULL
);

create table channel_txs (
    channel_outpoint TEXT NOT NULL REFERENCES channel_states(channel_outpoint),
    tx_hash TEXT NOT NULL,
    block_number TEXT NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    witness_args TEXT,
    commitment_args TEXT
);

create index idx_udt_dep_id on udt_dep(udt_info_id);
create index idx_node_udt_relations_udt on node_udt_relations(udt_info_id);
create index idx_node_udt_relations_node on node_udt_relations(node_id);
create index idx_daily_summarized_data_day on daily_summarized_data(day);
create index idx_channel_txs_outpoint on channel_txs(channel_outpoint);
create index idx_channel_states_state on channel_states(state);
create index idx_channel_states_last_commit_time on channel_states(last_commit_time);

create table node_infos (
    time TIMESTAMPTZ NOT NULL,
    node_name TEXT NOT NULL,
    node_id TEXT NOT NULL,
    addresses TEXT NOT NULL,
    announce_timestamp TIMESTAMPTZ NOT NULL,
    chain_hash TEXT NOT NULL,
    auto_accept_min_ckb_funding_amount TEXT NOT NULL,
    country_or_region TEXT,
    city TEXT,
    region TEXT,
    loc TEXT,
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='node_id',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_node_id_time
  ON node_infos(node_id, time DESC);
create index idx_node_name_time
  ON node_infos(node_name, time DESC);
create index idx_country_or_region_time
  ON node_infos(country_or_region, time DESC);

create table channel_infos (
    time TIMESTAMPTZ NOT NULL,
    channel_outpoint TEXT NOT NULL,
    node1 TEXT NOT NULL,
    node2 TEXT NOT NULL,
    capacity TEXT NOT NULL, -- u128 with hexadecimal format
    chain_hash TEXT NOT NULL,
    udt_type_script integer, -- foreign key to udt_infos
    created_timestamp TIMESTAMPTZ NOT NULL,
    update_of_node1_timestamp TIMESTAMPTZ,
    update_of_node1_enabled BOOLEAN,
    update_of_node1_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node1_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node1_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node1_fee_rate TEXT, -- u64 with hexadecimal format
    update_of_node2_timestamp TIMESTAMPTZ,
    update_of_node2_enabled BOOLEAN,
    update_of_node2_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node2_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node2_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node2_fee_rate TEXT -- u64 with hexadecimal format
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='channel_outpoint',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_channel_outpoint_time
  ON channel_infos(channel_outpoint, time DESC);


CREATE MATERIALIZED VIEW online_nodes_hourly
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  node_id,
  -- get the latest information for each node
  last(node_name, time) AS node_name,
  last(addresses, time) AS addresses,
  last(announce_timestamp, time) AS announce_timestamp,
  last(chain_hash, time) AS chain_hash,
  last(auto_accept_min_ckb_funding_amount, time) AS auto_accept_min_ckb_funding_amount,
  last(country_or_region, time) AS country_or_region,
  last(city, time) AS city,
  last(region, time) AS region,
  last(loc, time) AS loc
FROM node_infos
-- group by node ID to ensure each node appears only once
GROUP BY bucket, node_id
WITH NO DATA;

-- bucket by hour, so the data will be aggregated every hour
-- it means that 2025-08-07 03:00:00+00 will be aggregated after 2025-08-07 04:10:00+00
SELECT add_continuous_aggregate_policy(
  'online_nodes_hourly',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_nodes_hourly', INTERVAL '12 months');

create index idx_node_hourly_id_time
  ON online_nodes_hourly(node_id, bucket DESC);
create index idx_node_hourly_name_time
  ON online_nodes_hourly(node_name, bucket DESC);
create index idx_node_hourly_country_or_region_time
  ON online_nodes_hourly(country_or_region, bucket DESC);

CREATE MATERIALIZED VIEW mv_online_nodes as 
WITH latest_channels AS (
  SELECT DISTINCT ON (channel_outpoint) channel_outpoint, node1, node2
  FROM online_channels_hourly
  WHERE bucket >= now() - interval '3 hour'
  ORDER BY channel_outpoint, bucket DESC
),
channel_nodes AS (
  SELECT node1 AS node, channel_outpoint FROM latest_channels
  UNION ALL
  SELECT node2 AS node, channel_outpoint FROM latest_channels
),
channel_counts AS (
  SELECT node, COUNT(*) AS channel_count
  FROM channel_nodes
  GROUP BY node
)
SELECT DISTINCT ON (node_id) 
    n.node_id,
    n.node_name,
    n.addresses,
    n.announce_timestamp,
    n.chain_hash,
    n.auto_accept_min_ckb_funding_amount,
    n.country_or_region,
    n.city,
    n.region,
    n.loc,
    COALESCE(c.channel_count, 0) as channel_count,
    n.bucket
FROM online_nodes_hourly n
LEFT JOIN channel_counts c ON n.node_id = c.node
WHERE n.bucket >= now() - interval '6 hour'
ORDER BY n.node_id, n.bucket DESC;

CREATE UNIQUE INDEX idx_mv_online_nodes_node_id ON mv_online_nodes(node_id);
create index idx_mv_online_nodes_node_name ON mv_online_nodes(node_name);
create index idx_mv_online_nodes_country_or_region ON mv_online_nodes(country_or_region);
create index idx_mv_online_nodes_channel_count ON mv_online_nodes(channel_count);
create index idx_mv_online_nodes_bucket ON mv_online_nodes(bucket);

CREATE MATERIALIZED VIEW online_channels_hourly
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  channel_outpoint,
  -- get the latest information for each channel
  last(node1, time) AS node1,
  last(node2, time) AS node2,
  last(capacity, time) AS capacity,
  last(chain_hash, time) AS chain_hash,
  last(udt_type_script, time) AS udt_type_script,
  last(created_timestamp, time) AS created_timestamp,
  last(update_of_node1_timestamp, time) AS update_of_node1_timestamp,
  last(update_of_node1_enabled, time) AS update_of_node1_enabled,
  last(update_of_node1_outbound_liquidity, time) AS update_of_node1_outbound_liquidity,
  last(update_of_node1_tlc_expiry_delta, time) AS update_of_node1_tlc_expiry_delta,
  last(update_of_node1_tlc_minimum_value, time) AS update_of_node1_tlc_minimum_value,
  last(update_of_node1_fee_rate, time) AS update_of_node1_fee_rate,
  last(update_of_node2_timestamp, time) AS update_of_node2_timestamp,
  last(update_of_node2_enabled, time) AS update_of_node2_enabled,
  last(update_of_node2_outbound_liquidity, time) AS update_of_node2_outbound_liquidity,
  last(update_of_node2_tlc_expiry_delta, time) AS update_of_node2_tlc_expiry_delta,
  last(update_of_node2_tlc_minimum_value, time) AS update_of_node2_tlc_minimum_value,
  last(update_of_node2_fee_rate, time) AS update_of_node2_fee_rate
FROM channel_infos
-- group by channel outpoint to ensure each channel appears only once
GROUP BY bucket, channel_outpoint
WITH NO DATA;

SELECT add_continuous_aggregate_policy(
  'online_channels_hourly',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_channels_hourly', INTERVAL '12 months');

create index idx_channels_hourly_node1
  ON online_channels_hourly(node1, bucket DESC);

create index idx_channels_hourly_node2
  ON online_channels_hourly(node2, bucket DESC);

create index idx_channels_hourly_outpoint_time
  ON online_channels_hourly(channel_outpoint, bucket DESC);

CREATE MATERIALIZED VIEW mv_online_channels as 
SELECT DISTINCT ON (channel_outpoint)
    channel_outpoint,
    node1,
    node2,
    capacity,
    chain_hash,
    udt_type_script,
    created_timestamp,
    update_of_node1_timestamp,
    update_of_node1_enabled,
    update_of_node1_outbound_liquidity,
    update_of_node1_tlc_expiry_delta,
    update_of_node1_tlc_minimum_value,
    update_of_node1_fee_rate,
    update_of_node2_timestamp,
    update_of_node2_enabled,
    update_of_node2_outbound_liquidity,
    update_of_node2_tlc_expiry_delta,
    update_of_node2_tlc_minimum_value,
    update_of_node2_fee_rate,
    bucket
FROM online_channels_hourly
WHERE bucket >= now() - interval '6 hour'
ORDER BY channel_outpoint, bucket DESC;

CREATE UNIQUE INDEX idx_mv_online_channels_outpoint ON mv_online_channels(channel_outpoint);
create index idx_mv_online_channels_node1 ON mv_online_channels(node1);
create index idx_mv_online_channels_node2 ON mv_online_channels(node2);
create index idx_mv_online_channels_capacity ON mv_online_channels(capacity);
create index idx_mv_online_channels_create_time ON mv_online_channels(created_timestamp);

--- testnet

create table udt_infos_testnet (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text not null,
    code_hash text not null,
    hash_type varchar(10) not null,
    args text not null,
    auto_accept_amount text -- u64 with hexadecimal format
);

create table udt_dep_testnet (
    outpoint_tx_hash text,
    outpoint_index text,
    dep_type varchar(10),
    code_hash text,
    hash_type varchar(10),
    args text,
    udt_info_id integer not null references udt_infos_testnet(id)
);

create table node_udt_relations_testnet (
    node_id text not null,
    udt_info_id integer not null references udt_infos_testnet(id)
);

create table daily_summarized_data_testnet (
    day date NOT NULL PRIMARY KEY,
    channels_count JSONB NOT NULL,
    nodes_count INTEGER NOT NULL,
    capacity_analysis JSONB NOT NULL,
    asset_analysis JSONB NOT NULL
);

create table channel_states_testnet (
    channel_outpoint TEXT NOT NULL PRIMARY KEY,
    funding_args TEXT NOT NULL,
    capacity TEXT NOT NULL,
    udt_value TEXT,
    create_time TIMESTAMPTZ NOT NULL,
    last_commit_time TIMESTAMPTZ NOT NULL,
    last_tx_hash TEXT NOT NULL,
    last_block_number TEXT NOT NULL,
    last_commitment_args TEXT,
    state TEXT NOT NULL
);

create table channel_txs_testnet (
    channel_outpoint TEXT NOT NULL REFERENCES channel_states_testnet(channel_outpoint),
    tx_hash TEXT NOT NULL,
    block_number TEXT NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    witness_args TEXT,
    commitment_args TEXT
);

create index idx_udt_dep_id_testnet on udt_dep_testnet(udt_info_id);
create index idx_node_udt_relations_udt_testnet on node_udt_relations_testnet(udt_info_id);
create index idx_node_udt_relations_node_testnet on node_udt_relations_testnet(node_id);
create index idx_daily_summarized_data_day_testnet on daily_summarized_data_testnet(day);
create index idx_channel_txs_outpoint_testnet on channel_txs_testnet(channel_outpoint);
create index idx_channel_states_state_testnet on channel_states_testnet(state);
create index idx_channel_states_last_commit_time_testnet on channel_states_testnet(last_commit_time);

create table node_infos_testnet (
    time TIMESTAMPTZ NOT NULL,
    node_name TEXT NOT NULL,
    node_id TEXT NOT NULL,
    addresses TEXT NOT NULL,
    announce_timestamp TIMESTAMPTZ NOT NULL,
    chain_hash TEXT NOT NULL,
    auto_accept_min_ckb_funding_amount TEXT NOT NULL,
    country_or_region TEXT,
    city TEXT,
    region TEXT,
    loc TEXT
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='node_id',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_node_id_time_testnet
  ON node_infos_testnet(node_id, time DESC);
  create index idx_node_name_time_testnet
  ON node_infos_testnet(node_name, time DESC);
create index idx_country_or_region_time_testnet
  ON node_infos_testnet(country_or_region, time DESC);

create table channel_infos_testnet (
    time TIMESTAMPTZ NOT NULL,
    channel_outpoint TEXT NOT NULL,
    node1 TEXT NOT NULL,
    node2 TEXT NOT NULL,
    capacity TEXT NOT NULL, -- u128 with hexadecimal format
    chain_hash TEXT NOT NULL,
    udt_type_script integer, -- foreign key to udt_infos
    created_timestamp TIMESTAMPTZ NOT NULL,
    update_of_node1_timestamp TIMESTAMPTZ,
    update_of_node1_enabled BOOLEAN,
    update_of_node1_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node1_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node1_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node1_fee_rate TEXT, -- u64 with hexadecimal format
    update_of_node2_timestamp TIMESTAMPTZ,
    update_of_node2_enabled BOOLEAN,
    update_of_node2_outbound_liquidity TEXT, -- u128 with hexadecimal format
    update_of_node2_tlc_expiry_delta TEXT, -- u64 with hexadecimal format
    update_of_node2_tlc_minimum_value TEXT, -- u128 with hexadecimal format
    update_of_node2_fee_rate TEXT -- u64 with hexadecimal format
)
WITH (
  timescaledb.hypertable,
  timescaledb.partition_column='time',
  timescaledb.segmentby='channel_outpoint',
  timescaledb.chunk_interval='7 day'
);

create unique index idx_channel_outpoint_time_testnet
  ON channel_infos_testnet(channel_outpoint, time DESC);


CREATE MATERIALIZED VIEW online_nodes_hourly_testnet
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  node_id,
  -- get the latest information for each node
  last(node_name, time) AS node_name,
  last(addresses, time) AS addresses,
  last(announce_timestamp, time) AS announce_timestamp,
  last(chain_hash, time) AS chain_hash,
  last(auto_accept_min_ckb_funding_amount, time) AS auto_accept_min_ckb_funding_amount,
  last(country_or_region, time) AS country_or_region,
  last(city, time) AS city,
  last(region, time) AS region,
  last(loc, time) AS loc
FROM node_infos_testnet
-- group by node ID to ensure each node appears only once
GROUP BY bucket, node_id
WITH NO DATA;

-- bucket by hour, so the data will be aggregated every hour
-- it means that 2025-08-07 03:00:00+00 will be aggregated after 2025-08-07 04:10:00+00
SELECT add_continuous_aggregate_policy(
  'online_nodes_hourly_testnet',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_nodes_hourly_testnet', INTERVAL '12 months');

create index idx_node_hourly_id_time_testnet
  ON online_nodes_hourly_testnet(node_id, bucket DESC);
create index idx_node_hourly_name_time_testnet
  ON online_nodes_hourly_testnet(node_name, bucket DESC);
create index idx_node_hourly_country_or_region_time_testnet
  ON online_nodes_hourly_testnet(country_or_region, bucket DESC);

CREATE MATERIALIZED VIEW mv_online_nodes_testnet as 
WITH latest_channels AS (
  SELECT DISTINCT ON (channel_outpoint) channel_outpoint, node1, node2
  FROM online_channels_hourly_testnet
  WHERE bucket >= now() - interval '3 hour'
  ORDER BY channel_outpoint, bucket DESC
),
channel_nodes AS (
  SELECT node1 AS node, channel_outpoint FROM latest_channels
  UNION ALL
  SELECT node2 AS node, channel_outpoint FROM latest_channels
),
channel_counts AS (
  SELECT node, COUNT(*) AS channel_count
  FROM channel_nodes
  GROUP BY node
)
SELECT DISTINCT ON (n.node_id) 
    n.node_id,
    n.node_name,
    n.addresses,
    n.announce_timestamp,
    n.chain_hash,
    n.auto_accept_min_ckb_funding_amount,
    n.country_or_region,
    n.city,
    n.region,
    n.loc,
    COALESCE(c.channel_count, 0) as channel_count,
    n.bucket
FROM online_nodes_hourly_testnet n
LEFT JOIN channel_counts c ON n.node_id = c.node
WHERE n.bucket >= now() - interval '6 hour'
ORDER BY n.node_id, n.bucket DESC;

CREATE UNIQUE INDEX idx_mv_online_nodes_node_id_testnet ON mv_online_nodes_testnet(node_id);
create index idx_mv_online_nodes_node_name_testnet ON mv_online_nodes_testnet(node_name);
create index idx_mv_online_nodes_country_or_region_testnet ON mv_online_nodes_testnet(country_or_region);
create index idx_mv_online_nodes_channel_count_testnet ON mv_online_nodes_testnet(channel_count);
create index idx_mv_online_nodes_bucket_testnet ON mv_online_nodes_testnet(bucket);

CREATE MATERIALIZED VIEW online_channels_hourly_testnet
WITH (timescaledb.continuous) AS
SELECT
  -- time bucket by hour
  time_bucket('1 hour', time) AS bucket,
  channel_outpoint,
  -- get the latest information for each channel
  last(node1, time) AS node1,
  last(node2, time) AS node2,
  last(capacity, time) AS capacity,
  last(chain_hash, time) AS chain_hash,
  last(udt_type_script, time) AS udt_type_script,
  last(created_timestamp, time) AS created_timestamp,
  last(update_of_node1_timestamp, time) AS update_of_node1_timestamp,
  last(update_of_node1_enabled, time) AS update_of_node1_enabled,
  last(update_of_node1_outbound_liquidity, time) AS update_of_node1_outbound_liquidity,
  last(update_of_node1_tlc_expiry_delta, time) AS update_of_node1_tlc_expiry_delta,
  last(update_of_node1_tlc_minimum_value, time) AS update_of_node1_tlc_minimum_value,
  last(update_of_node1_fee_rate, time) AS update_of_node1_fee_rate,
  last(update_of_node2_timestamp, time) AS update_of_node2_timestamp,
  last(update_of_node2_enabled, time) AS update_of_node2_enabled,
  last(update_of_node2_outbound_liquidity, time) AS update_of_node2_outbound_liquidity,
  last(update_of_node2_tlc_expiry_delta, time) AS update_of_node2_tlc_expiry_delta,
  last(update_of_node2_tlc_minimum_value, time) AS update_of_node2_tlc_minimum_value,
  last(update_of_node2_fee_rate, time) AS update_of_node2_fee_rate
FROM channel_infos_testnet
-- group by channel outpoint to ensure each channel appears only once
GROUP BY bucket, channel_outpoint
WITH NO DATA;

SELECT add_continuous_aggregate_policy(
  'online_channels_hourly_testnet',
  start_offset => INTERVAL '3 hour',
  end_offset => INTERVAL '10 minute',
  schedule_interval => INTERVAL '5 minute'
);

SELECT add_retention_policy('online_channels_hourly_testnet', INTERVAL '12 months');

create index idx_channels_hourly_node1_testnet
  ON online_channels_hourly_testnet(node1, bucket DESC);

create index idx_channels_hourly_node2_testnet
  ON online_channels_hourly_testnet(node2, bucket DESC);

create index idx_channels_hourly_outpoint_time_testnet
  ON online_channels_hourly_testnet(channel_outpoint, bucket DESC);

CREATE MATERIALIZED VIEW mv_online_channels_testnet as 
SELECT DISTINCT ON (channel_outpoint)
    channel_outpoint,
    node1,
    node2,
    capacity,
    chain_hash,
    udt_type_script,
    created_timestamp,
    update_of_node1_timestamp,
    update_of_node1_enabled,
    update_of_node1_outbound_liquidity,
    update_of_node1_tlc_expiry_delta,
    update_of_node1_tlc_minimum_value,
    update_of_node1_fee_rate,
    update_of_node2_timestamp,
    update_of_node2_enabled,
    update_of_node2_outbound_liquidity,
    update_of_node2_tlc_expiry_delta,
    update_of_node2_tlc_minimum_value,
    update_of_node2_fee_rate,
    bucket
FROM online_channels_hourly_testnet
WHERE bucket >= now() - interval '6 hour'
ORDER BY channel_outpoint, bucket DESC;

CREATE UNIQUE INDEX idx_mv_online_channels_outpoint_testnet ON mv_online_channels_testnet(channel_outpoint);
create index idx_mv_online_channels_node1_testnet ON mv_online_channels_testnet(node1);
create index idx_mv_online_channels_node2_testnet ON mv_online_channels_testnet(node2);
create index idx_mv_online_channels_capacity_testnet ON mv_online_channels_testnet(capacity);
create index idx_mv_online_channels_create_time_testnet ON mv_online_channels_testnet(created_timestamp);
